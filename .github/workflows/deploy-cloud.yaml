name: Deploy - Oracle Cloud (Production)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      version:
        description: 'Version to deploy (tag, branch, or commit SHA)'
        required: true
        default: 'main'
        type: string
      rollback:
        description: 'Rollback to previous version'
        required: false
        default: 'false'
        type: boolean
  push:
    branches: [main]
    paths:
      - 'k8s/cloud/**'
      - 'scripts/deploy-cloud.sh'

env:
  REGISTRY: ghcr.io
  NAMESPACE: todo-app
  KUBECONFIG_PATH: /tmp/kubeconfig

jobs:
  deploy-cloud:
    name: Deploy to Oracle Cloud
    runs-on: ubuntu-latest
    environment: production

    outputs:
      previous_version: ${{ steps.get_previous_version.outputs.version }}
      current_version: ${{ github.sha }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.version || github.ref }}

      - name: Get previous version
        id: get_previous_version
        run: |
          # Get current deployed version from Kubernetes
          echo "version=$(kubectl get deployment -n ${{ env.NAMESPACE }} phase-v-backend -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo 'unknown')" >> $GITHUB_OUTPUT

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          
          # Test connection
          kubectl cluster-info
          kubectl get nodes

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push images
        if: ${{ inputs.rollback != 'true' }}
        run: |
          # Build and push backend
          docker build -t ${{ env.REGISTRY }}/${{ github.repository }}/backend:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ github.repository }}/backend:latest \
            ./backend
          docker push ${{ env.REGISTRY }}/${{ github.repository }}/backend:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ github.repository }}/backend:latest
          
          # Build and push frontend
          docker build -t ${{ env.REGISTRY }}/${{ github.repository }}/frontend:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ github.repository }}/frontend:latest \
            ./frontend
          docker push ${{ env.REGISTRY }}/${{ github.repository }}/frontend:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ github.repository }}/frontend:latest

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Install Dapr (if not installed)
        run: |
          if ! dapr status -k 2>/dev/null | grep -q "running"; then
            curl -fsSL https://raw.githubusercontent.com/dapr/cli/master/install/install.sh | bash
            dapr init -k --wait
          else
            echo "âœ… Dapr is already installed"
            dapr status -k
          fi

      - name: Apply Dapr components
        run: |
          kubectl apply -f k8s/cloud/dapr-components/

      - name: Deploy application
        run: |
          # Update image tags in deployment files
          export IMAGE_TAG=${{ github.sha }}
          
          kubectl apply -f k8s/base/
          kubectl apply -f k8s/cloud/

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment --all -n ${{ env.NAMESPACE }} --timeout=600s

      - name: Run health checks
        run: |
          echo "Running deployment health checks..."
          
          # Wait for all pods to be ready
          kubectl wait --for=condition=ready pod --all -n ${{ env.NAMESPACE }} --timeout=300s
          
          # Check deployment status
          kubectl get deployments -n ${{ env.NAMESPACE }}
          
          # Verify Dapr sidecars
          for deployment in $(kubectl get deployments -n ${{ env.NAMESPACE }} -o name); do
            POD=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=${deployment#deployment/} -o jsonpath='{.items[0].metadata.name}')
            if [ -n "$POD" ]; then
              CONTAINERS=$(kubectl get pod $POD -n ${{ env.NAMESPACE }} -o jsonpath='{.status.containerStatuses | length}')
              echo "$POD has $CONTAINERS containers"
              if [ "$CONTAINERS" -lt 2 ]; then
                echo "âš ï¸ Pod $POD may not have Dapr sidecar"
              fi
            fi
          done
          
          # Test health endpoint
          echo "Testing health endpoint..."
          for i in {1..10}; do
            if curl -f -k https://todo-app.example.com/health 2>/dev/null; then
              echo "âœ… Health check passed"
              break
            fi
            echo "Waiting for service... (attempt $i/10)"
            sleep 5
          done

      - name: Verify resource usage
        run: |
          echo "=== Resource Usage ==="
          kubectl top nodes 2>/dev/null || echo "Metrics server not available"
          kubectl top pods -n ${{ env.NAMESPACE }} 2>/dev/null || echo "Waiting for metrics..."
          
          # Check if within Always Free limits
          echo "Oracle Cloud Always Free Limits: 2 OCPU, 12GB RAM"
          echo "Current usage should be within these limits"

      - name: Get deployment status
        run: |
          echo "=== Deployment Status ==="
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          kubectl get deployments -n ${{ env.NAMESPACE }}
          kubectl get ingress -n ${{ env.NAMESPACE }}
          kubectl get certificates -n ${{ env.NAMESPACE }} 2>/dev/null || true

      - name: Rollback on failure
        if: failure() && inputs.rollback != 'true'
        run: |
          echo "âŒ Deployment failed, initiating rollback..."
          
          if [ "${{ steps.get_previous_version.outputs.version }}" != "unknown" ]; then
            echo "Rolling back to: ${{ steps.get_previous_version.outputs.version }}"
            kubectl rollout undo deployment --all -n ${{ env.NAMESPACE }}
            kubectl rollout status deployment --all -n ${{ env.NAMESPACE }} --timeout=300s
            echo "âœ… Rollback completed"
          else
            echo "âš ï¸ No previous version found, skipping rollback"
          fi

      - name: Notify success
        if: success()
        run: |
          echo "âœ… Deployment to Oracle Cloud completed successfully!"
          echo "Application URL: https://todo-app.example.com"
          echo "Deployed version: ${{ github.sha }}"

      - name: Notify failure
        if: failure()
        run: |
          echo "âŒ Deployment to Oracle Cloud failed!"
          echo "Debug information:"
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp'
          kubectl logs -n ${{ env.NAMESPACE }} -l app=phase-v-backend --tail=100

  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: deploy-cloud
    if: ${{ inputs.rollback == 'true' }}

    steps:
      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Perform rollback
        run: |
          echo "ðŸ”„ Rolling back deployment..."
          kubectl rollout undo deployment --all -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment --all -n ${{ env.NAMESPACE }} --timeout=600s
          
          echo "âœ… Rollback completed"
          echo "Previous version: ${{ needs.deploy-cloud.outputs.previous_version }}"

      - name: Verify rollback
        run: |
          kubectl get pods -n ${{ env.NAMESPACE }}
          kubectl get deployments -n ${{ env.NAMESPACE }}
